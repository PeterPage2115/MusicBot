import discord
from discord.ext import commands
import random
from utils.helpers import YTDLSource, YTDLError
from .utils import is_dj
import asyncio
import logging
import os
import traceback
import math
from utils.helpers import YTDLError
from utils.logger import get_logger

# Inicjalizacja loggera
logger = get_logger()

class QueuePaginator(discord.ui.View):
    """
    Widok do paginacji kolejki.
    
    Pozwala na nawigacjƒô po stronach kolejki za pomocƒÖ przycisk√≥w.
    """
    
    def __init__(self, pages, ctx, timeout=120):
        super().__init__(timeout=timeout)
        self.pages = pages
        self.total_pages = len(pages)
        self.current_page = 0
        self.ctx = ctx
        self.message = None
        
        # Wy≈ÇƒÖcz przyciski, je≈õli mamy tylko jednƒÖ stronƒô
        if self.total_pages <= 1:
            self.first_page.disabled = True
            self.prev_page.disabled = True
            self.next_page.disabled = True
            self.last_page.disabled = True
    
    @discord.ui.button(label="‚è™ Pierwsza", style=discord.ButtonStyle.primary)
    async def first_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        self.current_page = 0
        await self.update_page(interaction)
    
    @discord.ui.button(label="‚óÄÔ∏è Poprzednia", style=discord.ButtonStyle.secondary)
    async def prev_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        if self.current_page > 0:
            self.current_page -= 1
        await self.update_page(interaction)
    
    @discord.ui.button(label="‚ñ∂Ô∏è Nastƒôpna", style=discord.ButtonStyle.secondary)
    async def next_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        if self.current_page < self.total_pages - 1:
            self.current_page += 1
        await self.update_page(interaction)
    
    @discord.ui.button(label="‚è© Ostatnia", style=discord.ButtonStyle.primary)
    async def last_page(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer()
        self.current_page = self.total_pages - 1
        await self.update_page(interaction)
    
    async def update_page(self, interaction):
        """Aktualizuje stronƒô do wy≈õwietlenia"""
        # Pobierz bie≈ºƒÖcƒÖ stronƒô
        page = self.pages[self.current_page]
        
        # Zaktualizuj przyciski
        self.first_page.disabled = self.current_page == 0
        self.prev_page.disabled = self.current_page == 0
        self.next_page.disabled = self.current_page == self.total_pages - 1
        self.last_page.disabled = self.current_page == self.total_pages - 1
        
        # Aktualizuj wiadomo≈õƒá
        await interaction.message.edit(embed=page, view=self)
    
    async def on_timeout(self):
        """Obs≈Çuga timeout widoku"""
        # Wy≈ÇƒÖcz wszystkie przyciski po timeout
        self.first_page.disabled = True
        self.prev_page.disabled = True
        self.next_page.disabled = True
        self.last_page.disabled = True
        
        if self.message:
            await self.message.edit(view=self)


async def _toggle_repeat(self, ctx):
    """W≈ÇƒÖcza/wy≈ÇƒÖcza tryb powtarzania dla bie≈ºƒÖcego utworu."""
    guild_id = ctx.guild.id
    
    # Sprawd≈∫, czy bot jest na kanale g≈Çosowym
    if not ctx.voice_client:
        await ctx.send("‚ùå Nie jestem po≈ÇƒÖczony z kana≈Çem g≈Çosowym!")
        return
    
    # Sprawd≈∫, czy co≈õ jest odtwarzane
    if guild_id not in self.now_playing or not self.now_playing[guild_id]:
        await ctx.send("‚ùå Nic teraz nie gram!")
        return
    
    # Prze≈ÇƒÖcz tryb powtarzania
    if not hasattr(self, 'repeat_mode'):
        self.repeat_mode = {}
    
    # W≈ÇƒÖcz/wy≈ÇƒÖcz tryb powtarzania dla tego serwera
    current_mode = self.repeat_mode.get(guild_id, 0)
    
    # Tryby: 0 - wy≈ÇƒÖczony, 1 - powtarzanie utworu, 2 - powtarzanie kolejki
    if current_mode == 0:
        self.repeat_mode[guild_id] = 1
        await ctx.send("üîÇ Powtarzanie **bie≈ºƒÖcego utworu** w≈ÇƒÖczone")
    elif current_mode == 1:
        self.repeat_mode[guild_id] = 2
        await ctx.send("üîÅ Powtarzanie **ca≈Çej kolejki** w≈ÇƒÖczone")
    else:
        self.repeat_mode[guild_id] = 0
        await ctx.send("üîÑ Powtarzanie **wy≈ÇƒÖczone**")


async def _playlist(self, ctx, *, url):
    """
    Dodaje ca≈ÇƒÖ playlistƒô YouTube do kolejki.
    
    Args:
        ctx: Kontekst komendy
        url: URL playlisty YouTube
    """
    # Sprawd≈∫, czy bot jest na kanale g≈Çosowym
    if ctx.voice_client is None:
        if ctx.author.voice:
            await ctx.author.voice.channel.connect()
            await ctx.send(f"Do≈ÇƒÖczono do kana≈Çu {ctx.author.voice.channel.mention}")
        else:
            await ctx.send("Musisz byƒá na kanale g≈Çosowym, aby u≈ºyƒá tej komendy!")
            return
    
    # Sprawd≈∫, czy URL zawiera listƒô odtwarzania
    if "list=" not in url:
        await ctx.send("‚ö†Ô∏è To nie jest link do playlisty YouTube!")
        return
    
    # Zapisz kana≈Ç, na kt√≥rym wywo≈Çano komendƒô
    self.command_channels[ctx.guild.id] = ctx.channel
    
    # Dodaj playlistƒô do kolejki
    await self._add_playlist(ctx, url)


async def _add_playlist(self, ctx, playlist_url, *, max_tracks=100, chunk_size=25):
    """
    Dodaje playlistƒô do kolejki po kawa≈Çkach.
    
    Args:
        ctx: Kontekst komendy
        playlist_url: URL playlisty YouTube
        max_tracks: Maksymalna liczba utwor√≥w do dodania
        chunk_size: Rozmiar porcji do przetworzenia na raz
    """
    async with ctx.typing():
        try:
            await ctx.send(f"üîç Pobieram informacje o playli≈õcie...")
            
            # Przygotuj opcje yt-dlp
            ytdl_options = {
                'format': 'bestaudio/best',
                'outtmpl': 'temp/%(extractor)s-%(id)s-%(title)s.%(ext)s',
                'restrictfilenames': True,
                'noplaylist': False,  # Potrzebujemy playlist
                'nocheckcertificate': True,
                'ignoreerrors': False,
                'logtostderr': False,
                'quiet': True,
                'no_warnings': True,
                'default_search': 'auto',
                'source_address': '0.0.0.0',
                'extract_flat': True,  # Nie pobieraj wszystkich informacji na raz
                'force_generic_extractor': False
            }
            
            # Inicjalizacja YTDL
            import yt_dlp
            ydl = yt_dlp.YoutubeDL(ytdl_options)
            
            # Pobierz informacje o playli≈õcie
            info = await asyncio.get_event_loop().run_in_executor(
                None, lambda: ydl.extract_info(playlist_url, download=False)
            )
            
            if 'entries' not in info:
                await ctx.send("‚ùå Nie znaleziono playlisty lub wystƒÖpi≈Ç b≈ÇƒÖd!")
                return
            
            # Pobierz tytu≈Ç playlisty, je≈õli dostƒôpny
            playlist_title = info.get('title', 'Playlista YouTube')
            
            # Ogranicz liczbƒô utwor√≥w do max_tracks
            entries = info['entries'][:max_tracks]
            total_tracks = len(entries)
            
            if total_tracks == 0:
                await ctx.send("‚ùå Playlista jest pusta!")
                return
            
            # Wy≈õwietl informacje o playli≈õcie
            await ctx.send(f"üìã Dodajƒô playlistƒô **{playlist_title}** ({total_tracks} utwor√≥w)...")
            
            # Inicjalizacja kolejki dla tego serwera, je≈õli nie istnieje
            if ctx.guild.id not in self.queues:
                self.queues[ctx.guild.id] = []
            
            # Liczniki do ≈õledzenia postƒôpu
            added_count = 0
            failed_count = 0
            duplicate_count = 0
            
            # Pobierz informacje o ka≈ºdym utworze w playli≈õcie w mniejszych porcjach
            for i in range(0, total_tracks, chunk_size):
                chunk = entries[i:i+chunk_size]
                chunk_size_actual = len(chunk)
                
                # Aktualizuj status co ka≈ºdƒÖ porcjƒô
                if i > 0:
                    await ctx.send(f"‚è≥ Przetwarzanie {i}/{total_tracks} utwor√≥w...")
                
                for entry in chunk:
                    # Sprawd≈∫ czy mamy URL
                    if 'url' not in entry and 'id' not in entry:
                        failed_count += 1
                        continue
                    
                    # Utw√≥rz URL na podstawie ID, je≈õli potrzeba
                    video_url = entry.get('url', f"https://www.youtube.com/watch?v={entry.get('id')}")
                    
                    # Sprawd≈∫, czy utw√≥r ju≈º jest w kolejce (duplikat)
                    is_duplicate = False
                    for track in self.queues[ctx.guild.id]:
                        if track.url == video_url:
                            duplicate_count += 1
                            is_duplicate = True
                            break
                    
                    if is_duplicate:
                        continue
                    
                    try:
                        # Pobierz informacje o utworze
                        player = await YTDLSource.from_url(
                            video_url, 
                            loop=self.bot.loop, 
                            stream=True,
                            volume=0.5
                        )
                        
                        # Dodaj dodatkowe informacje
                        player.requester = ctx.author
                        
                        # Dodaj do kolejki
                        self.queues[ctx.guild.id].append(player)
                        added_count += 1
                    except Exception as e:
                        logger.error(f"B≈ÇƒÖd podczas dodawania utworu {video_url} do kolejki: {e}")
                        failed_count += 1
                
                # Daj czas na inne operacje asyncio
                await asyncio.sleep(0.1)
            
            # Wy≈õwietl podsumowanie
            message = f"‚úÖ Dodano **{added_count}** utwor√≥w do kolejki"
            if duplicate_count > 0:
                message += f", **{duplicate_count}** duplikat√≥w pominiƒôto"
            if failed_count > 0:
                message += f", **{failed_count}** nie uda≈Ço siƒô za≈Çadowaƒá"
            await ctx.send(message)
            
            # Rozpocznij odtwarzanie, je≈õli nic nie jest odtwarzane
            if ctx.voice_client and not ctx.voice_client.is_playing():
                await self._play_next(ctx)
                
        except Exception as e:
            logger.error(f"B≈ÇƒÖd podczas dodawania playlisty: {e}")
            await ctx.send(f"‚ùå WystƒÖpi≈Ç b≈ÇƒÖd podczas dodawania playlisty: {str(e)}")


async def _queue(self, ctx):
    """
    Wy≈õwietla aktualnƒÖ kolejkƒô utwor√≥w z paginacjƒÖ.
    """
    guild_id = ctx.guild.id
    
    # Sprawd≈∫, czy kolejka istnieje
    if guild_id not in self.queues or not self.queues[guild_id]:
        # Je≈õli jest co≈õ odtwarzane, poka≈º to
        if guild_id in self.now_playing and self.now_playing[guild_id]:
            player = self.now_playing[guild_id]
            embed = discord.Embed(
                title="üéµ Aktualnie odtwarzane",
                description=f"[{player.title}]({player.url})",
                color=discord.Color.blue()
            )
            
            # Dodaj miniaturƒô utworu
            if player.thumbnail:
                embed.set_thumbnail(url=player.thumbnail)
            
            # Dodaj informacje o utworze
            embed.add_field(name="Tw√≥rca", value=player.uploader, inline=True)
            embed.add_field(name="Czas trwania", value=player.duration, inline=True)
            embed.add_field(name="Na pro≈õbƒô", value=player.requester.mention, inline=True)
            
            embed.set_footer(text="Kolejka jest pusta.")
            await ctx.send(embed=embed)
        else:
            await ctx.send("‚ùå Kolejka jest pusta i nic nie jest odtwarzane!")
        return
    
    # Przygotuj zawarto≈õƒá kolejki do wy≈õwietlenia z paginacjƒÖ
    queue = self.queues[guild_id]
    items_per_page = 10
    pages = []
    
    # Oblicz liczbƒô stron
    page_count = math.ceil(len(queue) / items_per_page)
    
    # Utw√≥rz stronƒô dla ka≈ºdej czƒô≈õci kolejki
    for page_num in range(page_count):
        start_idx = page_num * items_per_page
        end_idx = start_idx + items_per_page
        page_items = queue[start_idx:end_idx]
        
        embed = discord.Embed(
            title=f"üìã Kolejka utwor√≥w - {guild_id}",
            color=discord.Color.blue()
        )
        
        # Dodaj informacje o aktualnie odtwarzanym utworze, je≈õli istnieje
        if guild_id in self.now_playing and self.now_playing[guild_id]:
            player = self.now_playing[guild_id]
            embed.add_field(
                name="üéµ Aktualnie odtwarzane",
                value=f"[{player.title}]({player.url}) | {player.duration} | {player.requester.mention}",
                inline=False
            )
        
        # Dodaj utwory na tej stronie
        tracks_details = []
        for i, track in enumerate(page_items, start=start_idx + 1):
            tracks_details.append(
                f"`{i}.` [{track.title}]({track.url}) | `{track.duration}` | {track.requester.mention}"
            )
        
        # Je≈õli mamy utwory na tej stronie, dodaj je
        if tracks_details:
            embed.add_field(
                name=f"Utwory w kolejce",
                value="\n".join(tracks_details),
                inline=False
            )
        
        # Dodaj informacje o stronie
        total_duration = sum(track.duration_raw for track in queue)
        minutes, seconds = divmod(total_duration, 60)
        hours, minutes = divmod(minutes, 60)
        
        # Formatuj czas ca≈Çkowity
        if hours > 0:
            total_time = f"{hours}h {minutes}m {seconds}s"
        else:
            total_time = f"{minutes}m {seconds}s"
        
        embed.set_footer(text=f"Strona {page_num + 1}/{page_count} ‚Ä¢ {len(queue)} utwor√≥w ‚Ä¢ ≈ÅƒÖczny czas: {total_time}")
        
        # Dodaj stronƒô do listy stron
        pages.append(embed)
    
    # Je≈õli mamy tylko jednƒÖ stronƒô, wy≈õlij jƒÖ bez paginacji
    if len(pages) == 1:
        await ctx.send(embed=pages[0])
    else:
        # W przeciwnym razie u≈ºyj paginatora
        view = QueuePaginator(pages, ctx)
        message = await ctx.send(embed=pages[0], view=view)
        view.message = message


# Funkcja ustawiajƒÖca komendy kolejki
def setup_queue_commands(cog):
    """
    Konfiguruje komendy zwiƒÖzane z kolejkƒÖ.
    
    Args:
        cog: Instancja klasy Music
    """
    # Inicjalizuj kolekcje, je≈õli nie istniejƒÖ
    if not hasattr(cog, 'queues'):
        cog.queues = {}
    
    if not hasattr(cog, 'now_playing'):
        cog.now_playing = {}
    
    if not hasattr(cog, '_queue_history'):
        cog._queue_history = {}
    
    # Przypisz metody do cog
    cog._toggle_repeat = _toggle_repeat.__get__(cog, type(cog))
    cog._playlist = _playlist.__get__(cog, type(cog))
    cog._add_playlist = _add_playlist.__get__(cog, type(cog))
    cog._queue = _queue.__get__(cog, type(cog))
    
    # Alias dla kompatybilno≈õci
    cog.queue = cog._queue
    cog.playlist = cog._playlist
    cog.toggle_repeat = cog._toggle_repeat
    
    # Komendy dla modu≈Çu queue_manager
    @cog.bot.command(name="remove", aliases=["usun"], help="Usuwa utw√≥r z kolejki")
    @is_dj()
    async def remove_command(ctx, *, index: int):
        """Usuwa utw√≥r z kolejki"""
        guild_id = ctx.guild.id
        
        # Sprawd≈∫ czy kolejka istnieje
        if guild_id not in cog.queues or not cog.queues[guild_id]:
            await ctx.send("‚ùå Kolejka jest pusta!")
            return
        
        # Sprawd≈∫ czy indeks jest poprawny
        if index < 1 or index > len(cog.queues[guild_id]):
            await ctx.send(f"‚ö†Ô∏è Podaj poprawny numer utworu (1-{len(cog.queues[guild_id])})!")
            return
        
        # Pobierz utw√≥r do usuniƒôcia
        track = cog.queues[guild_id][index-1]
        
        # Usu≈Ñ utw√≥r z kolejki
        cog.queues[guild_id].pop(index-1)
        
        # Wy≈õlij potwierdzenie
        await ctx.send(f"‚úÖ Usuniƒôto z kolejki: **{track.title}**")
    
    @cog.bot.command(name="shuffle", aliases=["pomieszaj"], help="Miesza kolejkƒô utwor√≥w")
    @is_dj()
    async def shuffle_command(ctx):
        """Miesza kolejkƒô utwor√≥w"""
        guild_id = ctx.guild.id
        
        # Sprawd≈∫ czy kolejka istnieje
        if guild_id not in cog.queues or not cog.queues[guild_id]:
            await ctx.send("‚ùå Kolejka jest pusta!")
            return
        
        # Zapisz d≈Çugo≈õƒá kolejki przed mieszaniem
        queue_length = len(cog.queues[guild_id])
        
        # Pomieszaj kolejkƒô
        import random
        random.shuffle(cog.queues[guild_id])
        
        # Wy≈õlij potwierdzenie
        await ctx.send(f"üîÄ Pomieszano {queue_length} utwor√≥w w kolejce!")
    
    @cog.bot.command(name="clear_queue", aliases=["wyczysc_kolejke", "clear_music"], help="Czy≈õci kolejkƒô utwor√≥w")
    @is_dj()
    async def clear_command(ctx):
        """Czy≈õci kolejkƒô utwor√≥w"""
        guild_id = ctx.guild.id
        
        # Sprawd≈∫ czy kolejka istnieje
        if guild_id not in cog.queues or not cog.queues[guild_id]:
            await ctx.send("‚ùå Kolejka ju≈º jest pusta!")
            return
        
        # Zapisz d≈Çugo≈õƒá kolejki przed czyszczeniem
        queue_length = len(cog.queues[guild_id])
        
        # Wyczy≈õƒá kolejkƒô
        cog.queues[guild_id] = []
        
        # Wy≈õlij potwierdzenie
        await ctx.send(f"üßπ Wyczyszczono kolejkƒô ({queue_length} utwor√≥w)!")
        
    @cog.bot.command(name="move", aliases=["przenies"], help="Przenosi utw√≥r na innƒÖ pozycjƒô w kolejce")
    @is_dj()
    async def move_command(ctx, from_pos: int, to_pos: int):
        """Przenosi utw√≥r na innƒÖ pozycjƒô w kolejce"""
        guild_id = ctx.guild.id
        
        # Sprawd≈∫ czy kolejka istnieje
        if guild_id not in cog.queues or not cog.queues[guild_id]:
            await ctx.send("‚ùå Kolejka jest pusta!")
            return
        
        # Sprawd≈∫ poprawno≈õƒá indeks√≥w (u≈ºytkownicy numerujƒÖ od 1)
        queue_length = len(cog.queues[guild_id])
        if from_pos < 1 or from_pos > queue_length or to_pos < 1 or to_pos > queue_length:
            await ctx.send(f"‚ö†Ô∏è Podaj poprawne numery utwor√≥w (1-{queue_length})!")
            return
        
        # Pobierz utw√≥r do przeniesienia
        track = cog.queues[guild_id][from_pos-1]
        
        # Usu≈Ñ z oryginalnej pozycji
        cog.queues[guild_id].pop(from_pos-1)
        
        # Wstaw na nowej pozycji
        cog.queues[guild_id].insert(to_pos-1, track)
        
        # Wy≈õlij potwierdzenie
        await ctx.send(f"‚úÖ Przeniesiono **{track.title}** z pozycji {from_pos} na {to_pos}!")
    
    return cog